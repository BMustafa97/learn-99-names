name: Build and Deploy

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even on non-main branch'
        required: false
        default: false
        type: boolean

env:
  ECR_REPOSITORY: arabic-recognition-app
  APPRUNNER_SERVICE: ar-recognition-dev
  AWS_REGION: eu-west-1

jobs:
  changes:
    runs-on: ubuntu-latest
    outputs:
      deploy-needed: ${{ steps.changes.outputs.deploy-needed }}
      image-tag: ${{ steps.meta.outputs.image-tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check for deployment changes
        id: changes
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.event.inputs.force_deploy }}" == "true" ]] || [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "deploy-needed=true" >> $GITHUB_OUTPUT
          else
            echo "deploy-needed=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate image metadata
        id: meta
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            IMAGE_TAG=${GITHUB_REF#refs/tags/}
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            IMAGE_TAG="latest"
          else
            IMAGE_TAG="pr-${{ github.event.number }}"
          fi
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Image tag will be: ${IMAGE_TAG}"

  build:
    runs-on: ubuntu-latest
    needs: changes
    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}
      image-digest: ${{ steps.build-image.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies and generate lockfile
        run: |
          npm ci || npm install
          # Ensure package-lock.json exists for Docker build
          test -f package-lock.json

      - name: Run pre-build tests
        run: |
          # Quick smoke test
          echo "Running pre-build validation..."
          
          # Validate package.json structure
          node -e "require('./package.json')"
          
          # Check if main files exist
          test -f src/index.html
          test -f src/learn-names.js
          
          echo "Pre-build validation passed"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        if: needs.changes.outputs.deploy-needed == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        if: needs.changes.outputs.deploy-needed == 'true'
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and test Docker image locally
        run: |
          # Build the image
          docker build -t ${{ env.ECR_REPOSITORY }}:test .
          
          # Test the image
          docker run -d --name test-container -p 3000:3000 ${{ env.ECR_REPOSITORY }}:test
          
          # Wait for container to start
          sleep 10
          
          # Health check
          for i in {1..12}; do
            if curl -f http://localhost:3000/ >/dev/null 2>&1; then
              echo "Container health check passed"
              break
            fi
            echo "Waiting for container to be ready... ($i/12)"
            sleep 5
          done
          
          # Verify the response
          curl -f http://localhost:3000/ || exit 1
          
          # Check container logs
          docker logs test-container
          
          # Cleanup
          docker stop test-container
          docker rm test-container

      - name: Run Docker Compose integration test
        run: |
          # Test with docker compose (V2)
          docker compose up -d
          
          # Wait for services to be ready
          sleep 15
          
          # Health check via compose
          for i in {1..10}; do
            if docker compose ps | grep -q "healthy\|Up"; then
              echo "Docker Compose services are healthy"
              break
            fi
            echo "Waiting for Docker Compose services... ($i/10)"
            sleep 5
          done
          
          # Test endpoint
          curl -f http://localhost:3000/ || exit 1
          echo "Docker Compose integration test passed"
          
          # Cleanup
          docker compose down

      - name: Build and push to ECR
        if: needs.changes.outputs.deploy-needed == 'true'
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ needs.changes.outputs.image-tag }}
        run: |
          # Build and tag image
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          # Push images
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          # Output image URI and digest
          IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          IMAGE_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG || echo "")
          
          echo "image=$IMAGE_URI" >> $GITHUB_OUTPUT
          echo "digest=$IMAGE_DIGEST" >> $GITHUB_OUTPUT
          echo "Image pushed: $IMAGE_URI"

      - name: Run security scan on pushed image
        if: needs.changes.outputs.deploy-needed == 'true'
        continue-on-error: true
        run: |
          # Run Trivy scan on the pushed image
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy image --exit-code 0 --severity HIGH,CRITICAL \
            ${{ steps.build-image.outputs.image }}

  deploy:
    runs-on: ubuntu-latest
    needs: [changes, build]
    if: needs.changes.outputs.deploy-needed == 'true' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check AWS infrastructure
        run: |
          echo "üîç Checking AWS infrastructure exists..."
          
          # Check if ECR repository exists
          if aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} >/dev/null 2>&1; then
            echo "‚úÖ ECR repository '${{ env.ECR_REPOSITORY }}' exists"
          else
            echo "‚ùå ECR repository '${{ env.ECR_REPOSITORY }}' not found"
            exit 1
          fi
          
          # Check if App Runner service exists
          SERVICE_ARN=$(aws apprunner list-services --query "ServiceSummaryList[?ServiceName=='${{ env.APPRUNNER_SERVICE }}'].ServiceArn | [0]" --output text 2>/dev/null || echo "None")
          
          if [[ "$SERVICE_ARN" != "None" && "$SERVICE_ARN" != "" ]]; then
            echo "‚úÖ App Runner service '${{ env.APPRUNNER_SERVICE }}' exists"
            echo "Service ARN: $SERVICE_ARN"
            
            # Check service status
            SERVICE_STATUS=$(aws apprunner describe-service --service-arn "$SERVICE_ARN" --query 'Service.Status' --output text)
            echo "Service Status: $SERVICE_STATUS"
          else
            echo "‚ùå App Runner service '${{ env.APPRUNNER_SERVICE }}' not found"
            echo "üí° Deploy infrastructure first: cd terraform && terraform apply"
            exit 1
          fi
          
          echo "üéâ All required infrastructure exists"

      - name: Trigger App Runner deployment
        run: |
          echo "üöÄ Triggering App Runner deployment..."
          
          # Get service ARN
          SERVICE_ARN=$(aws apprunner list-services --query "ServiceSummaryList[?ServiceName=='${{ env.APPRUNNER_SERVICE }}'].ServiceArn | [0]" --output text)
          
          if [[ "$SERVICE_ARN" == "None" || "$SERVICE_ARN" == "" ]]; then
            echo "‚ùå Could not find App Runner service"
            exit 1
          fi
          
          # App Runner automatically deploys when new images are pushed to ECR (if auto-deployments enabled)
          # But we can also trigger a manual deployment
          echo "üîÑ App Runner will automatically detect the new image and deploy"
          echo "Service ARN: $SERVICE_ARN"
          
          # Optionally force a new deployment
          # aws apprunner start-deployment --service-arn "$SERVICE_ARN"

      - name: Wait for deployment completion
        run: |
          echo "‚è≥ Waiting for App Runner deployment to complete..."
          
          SERVICE_ARN=$(aws apprunner list-services --query "ServiceSummaryList[?ServiceName=='${{ env.APPRUNNER_SERVICE }}'].ServiceArn | [0]" --output text)
          
          # Wait for deployment to complete (max 10 minutes)
          for i in {1..60}; do
            STATUS=$(aws apprunner describe-service --service-arn "$SERVICE_ARN" --query 'Service.Status' --output text)
            echo "Deployment attempt $i/60 - Service Status: $STATUS"
            
            if [[ "$STATUS" == "RUNNING" ]]; then
              echo "‚úÖ App Runner service is running successfully!"
              break
            elif [[ "$STATUS" == "OPERATION_IN_PROGRESS" ]]; then
              echo "üîÑ Deployment in progress..."
              sleep 10
            elif [[ "$STATUS" == "CREATE_FAILED" || "$STATUS" == "UPDATE_FAILED" ]]; then
              echo "‚ùå Deployment failed with status: $STATUS"
              exit 1
            else
              echo "‚è≥ Current status: $STATUS, waiting..."
              sleep 10
            fi
          done
          
          # Final status check
          FINAL_STATUS=$(aws apprunner describe-service --service-arn "$SERVICE_ARN" --query 'Service.Status' --output text)
          if [[ "$FINAL_STATUS" != "RUNNING" ]]; then
            echo "‚ùå Deployment did not complete successfully. Final status: $FINAL_STATUS"
            exit 1
          fi

      - name: Verify deployment
        run: |
          echo "üîç Verifying App Runner deployment..."
          
          SERVICE_ARN=$(aws apprunner list-services --query "ServiceSummaryList[?ServiceName=='${{ env.APPRUNNER_SERVICE }}'].ServiceArn | [0]" --output text)
          
          # Get service URL
          SERVICE_URL=$(aws apprunner describe-service --service-arn "$SERVICE_ARN" --query 'Service.ServiceUrl' --output text)
          echo "üåê Service URL: https://$SERVICE_URL"
          
          # Health check
          echo "üè• Performing health check..."
          for i in {1..10}; do
            if curl -f --max-time 10 "https://$SERVICE_URL/" >/dev/null 2>&1; then
              echo "‚úÖ Health check passed! Application is responding"
              break
            else
              echo "‚è≥ Health check attempt $i/10 failed, retrying in 15 seconds..."
              sleep 15
            fi
          done
          
          # Final health check
          if curl -f --max-time 30 "https://$SERVICE_URL/" >/dev/null 2>&1; then
            echo "üéâ Deployment verification successful!"
            echo "üåç Application is live at: https://$SERVICE_URL"
          else
            echo "‚ùå Health check failed - application may not be responding"
            echo "üîç Check App Runner logs: aws logs tail /aws/apprunner/${{ env.APPRUNNER_SERVICE }}/application --follow"
            exit 1
          fi

      - name: Create deployment summary
        run: |
          echo "## üöÄ App Runner Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Get service details
          SERVICE_ARN=$(aws apprunner list-services --query "ServiceSummaryList[?ServiceName=='${{ env.APPRUNNER_SERVICE }}'].ServiceArn | [0]" --output text)
          SERVICE_URL=$(aws apprunner describe-service --service-arn "$SERVICE_ARN" --query 'Service.ServiceUrl' --output text)
          
          echo "**Container Image:** \`${{ needs.build.outputs.image-uri }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**App Runner Service:** \`${{ env.APPRUNNER_SERVICE }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Region:** \`${{ env.AWS_REGION }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Service URL:** [https://$SERVICE_URL](https://$SERVICE_URL)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ‚úÖ App Runner deployment completed successfully" >> $GITHUB_STEP_SUMMARY
          echo "**Infrastructure:** AWS App Runner (Fully Managed)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** [\`${{ github.sha }}\`](https://github.com/${{ github.repository }}/commit/${{ github.sha }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üéØ Key Benefits" >> $GITHUB_STEP_SUMMARY
          echo "- üöÄ Zero infrastructure management" >> $GITHUB_STEP_SUMMARY
          echo "- üí∞ ~60% cost reduction vs ECS+ALB" >> $GITHUB_STEP_SUMMARY
          echo "- üîí Automatic HTTPS and security" >> $GITHUB_STEP_SUMMARY
          echo "- üìà Auto-scaling (1-10 instances)" >> $GITHUB_STEP_SUMMARY

  notify:
    runs-on: ubuntu-latest
    needs: [changes, build, deploy]
    if: always() && needs.changes.outputs.deploy-needed == 'true'

    steps:
      - name: Deployment notification
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "‚úÖ App Runner deployment completed successfully"
            echo "üöÄ Fully managed container service with automatic HTTPS"
            echo "üí∞ Cost optimized: ~60% savings vs traditional ECS+ALB"
            echo "üì¶ Container Image: ${{ needs.build.outputs.image-uri }}"
            echo "üîó Commit: ${{ github.sha }}"
          elif [[ "${{ needs.deploy.result }}" == "failure" ]]; then
            echo "‚ùå App Runner deployment failed"
            echo "üîç Check App Runner service logs and status"
            echo "üí° Troubleshooting: aws apprunner describe-service --service-arn <service-arn>"
          elif [[ "${{ needs.build.result }}" == "failure" ]]; then
            echo "‚ùå Container build failed"
            echo "üîç Please check the build logs and container configuration"
          else
            echo "‚ÑπÔ∏è Build completed but App Runner deployment was skipped"
            echo "üìù Branch: ${{ github.ref }}"
            echo "üí° App Runner deploys only from main branch"
          fi
